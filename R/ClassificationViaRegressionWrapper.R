#' @title Classification via regression wrapper.
#'
#' @description
#' Builds regression models that predict for each class separately whether a particular example belongs to it (1) or not (-1). Predictions probabilities are aggregated by selecting the class with the largest predicted value.
#'
#' Probabilities are generated by transforming the predictions with a softmax.
#'
#' @template arg_learner
#' @param cvrw.predict.type [\code{character(1)}]\cr
#'   \dQuote{response} (= labels) or \dQuote{prob} (= probabilities and labels by selecting the ones with maximal probability).
#' @param ... [any]\cr
#'   Additional parameters passed down to the wrapped learner.
#' @template ret_learner
#' @export
#' @family wrapper
#' @examples
#' lrn = makeLearner("regr.rpart")
#' lrn = makeClassificationViaRegressionWrapper(lrn)
#' mod = train(lrn, iris.task, subset = 1:100)
#' predictions = predict(mod, newdata = iris[101:150, 1:4])
makeClassificationViaRegressionWrapper = function(learner, predict.type = "response") {
  learner = checkLearner(learner, "regr")
  lrn = makeBaseWrapper(
    id = stri_paste(learner$id, "classify", sep = "."),
    type = "classif",
    next.learner = learner,
    package = "mlr",
    par.set = makeParamSet(),
    par.vals = list(),
    learner.subclass = "ClassificationViaRegressionWrapper",
    model.subclass = "ClassificationViaRegressionModel"
  )
  lrn$predict.type = predict.type
  return(lrn)
}

#' @export
trainLearner.ClassificationViaRegressionWrapper = function(.learner, .task, .subset, .weights = NULL, ...) {
  classes = getTaskClassLevels(.task)
  td =  getTaskData(.task, target.extra = TRUE, subset = .subset)
  models = lapply(classes, function(class) {
    targetName = stri_paste(class, "prob", sep = ".")
    data = td$data
    data[[targetName]] = ifelse(td$target == class, 1, -1)
    regr.task = makeRegrTask(
      id = stri_paste(getTaskId(.task), class, sep = "."),
      data = data,
      target = targetName,
      weights = getTaskWeights(.task),
      blocking = .task$blocking)
    list(
      model = train(.learner$next.learner, regr.task, weights = .weights),
      class = class
    )
  })
  makeChainModel(next.model = models, cl = "ClassificationViaRegressionModel")
}

#' @export
predictLearner.ClassificationViaRegressionWrapper = function(.learner, .model, .newdata, ...) {
  models = getLearnerModel(.model, more.unwrap = FALSE)
  p = asMatrixCols(lapply(models, function(m) {
    predict(m$model, newdata = .newdata, ...)$data$response
  }))
  colnames(p) = vcapply(models, function(m) m$class)

  if (.learner$predict.type == "response") {
    factor(colnames(p)[apply(p, 1, which.max)], levels = .model$task.desc$class.levels)
  } else {
    t(apply(p, 1, function(x) exp(x)/sum(exp(x))))
  }
}

#' @export
getLearnerProperties.ClassificationViaRegressionWrapper = function(learner) {
  props = getLearnerProperties(learner$next.learner)
  props = union(props, c("twoclass", "multiclass", "prob"))
  intersect(props, getSupportedLearnerProperties("classif"))
}

#' @export
setPredictType.ClassificationViaRegressionWrapper = function(learner, predict.type) {
  assertChoice(predict.type, c("response", "prob"))
  learner$predict.type = predict.type
}

#' @export
isFailureModel.ClassificationViaRegressionModel = function(model) {
  mods = getLearnerModel(model, more.unwrap = FALSE)
  mods = extractSubList(mods, "model", simplify = FALSE)
  any(vlapply(mods, isFailureModel))
}
